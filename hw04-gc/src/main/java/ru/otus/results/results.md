| размер хипа | Результат 1,мс | Результат 2,мс | Результат 3,мс |
|-------------|----------------|----------------|----------------|
| 256m        | 7 667          | 8 045          | 7 563          |
| 2048m       | 3 613          | 3 600          | 3 363          |
| 16384m      | 4 021          | 4 164          | 3 813          |
| 1024m       | 3 822          | 4 153          | 3 526          |
| 512m        | 4 592          | 4 428          | 4 357          |

Вывод: оптимальный размер хипа - 1024m

Оптимизация GC при размере хипа 1024m:

| Вид      | Результат,мс | Настройка                                   |
|----------|--------------|---------------------------------------------|
| Serial   | 9 274        | -XX:+UseSerialGC                            |
| Parallel | 20 303       | -XX:+UseParallelGC                          |
| Parallel | 20 098       | -XX:+UseParallelGC -XX:ParallelGCThreads=10 |
| G1       | 3 951        | -XX:+UseG1GC                                |
| ZGC      | 3 195        | -XX:+UseZGC                                 |

Вывод: При выборе вида GC "ZGC" получили небольшой прирост в производительности.
Пробуем поиграться с настройкой количества выделенных на сборку мусора потоков:

| размер хипа | Результат 1,мс | Результат 2,мс | Результат 3,мс | Настройка                        |
|-------------|----------------|----------------|----------------|----------------------------------|
| 256m        | 3 195          | 3 312          | 3 277          | -XX:+UseZGC                      |
| 2048m       | 4 217          | 3 719          | 3 317          | -XX:+UseZGC -XX:ConcGCThreads=2  |
| 2048m       | 3 007          | 2 727          | 2 916          | -XX:+UseZGC -XX:ConcGCThreads=8  |
| 2048m       | 3 553          | 2 696          | 3 032          | -XX:+UseZGC -XX:ConcGCThreads=10 |

Вывод: Для данного приложения рекомендуются настройки JVM "-XX:+UseZGC -XX:ConcGCThreads=8 -Xms1024m -Xmx1024m"

После правок кода время выполнения уменьшилось до 474мс.
Попробуем уменьшить размер хипа и замерить результаты:

| размер хипа | Результат 1,мс | Результат 2,мс | Результат 3,мс |
|-------------|----------------|----------------|----------------|
| 1024m       | 474            | 475            | 472            |
| 256m        | 486            | 474            | 475            |
| 64m         | 472            | 473            | 474            |

Попробуем прикинуть размер максимально необходимой памяти для хранения всех данных(как если бы GC не работал)
Самый большой объем - объекты Data. 
Он занимает в памяти: 
Заголовок: 8 байт 
Поле int: 4 байта
Плюс 4 байта для кратности 8
Итого: 16 байт

100_000_000 * 16 байт = 16мб

| размер хипа | Результат 1,мс | Результат 2,мс | Результат 3,мс |
|-------------|----------------|----------------|----------------|
| 16m         | 480            | 480            | 482            |
| 8m          | 501            | 509            | OutOfMemory    |

Вывод: После изменений в коде удалось уменьшить размер хипа по 16m и наиболее эффективные настройки JVM стали ""-XX:+UseZGC -XX:ConcGCThreads=8 -Xms16m -Xmx16m""
Вывод 2: Наглядно убедились, что зачастую оптимизировать код намного выгоднее, чем настраивать GC
